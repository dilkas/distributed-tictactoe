While Java RMI provides a simplified approach to object manipulation over distributed systems, it does force the use of TCP sockets by default. The reliable, ordered delivery of data provided by TCP is desirable for distributed applications, however, this choice of transport protocol does have significant implications for application topology.

The ongoing shortage of IPv4 addresses has led to a large proportion of machines on the Internet to be obscured by Network Address Translation (NAT) middleboxes. Machines hidden behind one of these middleboxes cannot be contacted directly without the use of techniques like hole punching, which is a significant problem for establishing an entirely decentralised peer-to-peer system.

Hole punching for NAT traversal requires the use of an external, publicly-accessible proxy server to distribute the public-facing IP address and port combinations (addr:port) of NAT-obscured clients which want to establish a peer-to-peer session. This traversal method is used by many popular distributed applications such as multiplayer gaming, Skype, and peer-to-peer filesharing. This technique takes advantage of the behaviour of NAT middleboxes to create and maintain an 'open' addr:port combination - without this, a fully decentralised peer-to-peer session cannot be established.

As mentioned above, Java RMI uses TCP for its operations by default. While it is possible to modify the sockets created by RMI calls to use UDP instead, this requires extensive work using RMISocketFactory which is beyond the time allowed by the project.

UDP is the more commonly used transport protocol for peer-to-peer applications - one socket can be used for both sending and receiving messages from multiple clients without the need for establishing a fixed connection between two endpoints. Although adjustments would need to be made to allow for unordered or lost messages, UDP would allow us to implement a topology with good fault tolerance and Internet-wide access, as displayed in figure (INCLUDE IMAGE HERE).

An alternative approach is to attempt TCP hole punching instead. This requires creating four TCP sockets with bound to the same local addr:port combination (ie. with SO_REUSEADDR enabled) to establish a connection with a peer through a proxy server, as described in section 4 of a study by Ford, et al (INCLUDE CITATION HERE). Not only is this a significant overhead, with four sockets and multiple ports required for each peer a client wants to make contact with, it is also more complex to perform than the UDP equivalent; our simplified Python-based tests could not establish contact between peers using the instructions described in the Ford paper.

Without significant adjustments to the type of sockets used by Java RMI, a better understanding of TCP hole punching, or the universal adoption of IPv6, our application is currently limited to operating within local networks only. This is acceptable for its use as an educational tool, where it can be used within corporate or university networks freely, but the lack of NAT traversal largely excludes its use as a casual multiplayer game given that the vast majority of homes obscure several devices behind an ISP-provided NAT middlebox.

While we are aiming to create a system without unnecessary complexity for educational purposes, NAT is a core component of the modern Internet - all networks programmers will encounter difficulties with it at some stage and having a solution to demonstrate as part of our application would have been very beneficial to people using it for educational purposes.

